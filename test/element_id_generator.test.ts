import { expect } from "chai";
import { ElementId, ElementIdGenerator } from "../src";

describe("ElementIdGenerator", () => {
  let generator: ElementIdGenerator;
  let mockUuidCounter: number;

  // Mock UUID generator for predictable testing
  const mockNewBunchId = (): string => {
    return `test-uuid-${++mockUuidCounter}`;
  };

  beforeEach(() => {
    mockUuidCounter = 0;
    generator = new ElementIdGenerator(mockNewBunchId);
  });

  describe("uniqueness", () => {
    it("should generate unique ElementIds", () => {
      const ids: ElementId[] = [];
      const numIds = 100;

      // Generate many IDs
      let previousId: ElementId | null = null;
      for (let i = 0; i < numIds; i++) {
        const id = generator.generateAfter(previousId);
        ids.push(id);
        previousId = id;
      }

      // Check that all IDs are unique
      const uniqueIds = new Set(ids.map((id) => `${id.bunchId}-${id.counter}`));
      expect(uniqueIds.size).to.equal(
        numIds,
        "All generated IDs should be unique"
      );
    });

    it("should generate unique ElementIds across multiple generators", () => {
      const generator1 = new ElementIdGenerator(
        () => `gen1-${Date.now()}-${Math.random()}`
      );
      const generator2 = new ElementIdGenerator(
        () => `gen2-${Date.now()}-${Math.random()}`
      );

      const ids1: ElementId[] = [];
      const ids2: ElementId[] = [];

      // Generate IDs from both generators
      let prev1: ElementId | null = null;
      let prev2: ElementId | null = null;

      for (let i = 0; i < 50; i++) {
        const id1 = generator1.generateAfter(prev1);
        const id2 = generator2.generateAfter(prev2);
        ids1.push(id1);
        ids2.push(id2);
        prev1 = id1;
        prev2 = id2;
      }

      // Combine all IDs and check uniqueness
      const allIds = [...ids1, ...ids2];
      const uniqueIds = new Set(
        allIds.map((id) => `${id.bunchId}-${id.counter}`)
      );
      expect(uniqueIds.size).to.equal(
        allIds.length,
        "IDs from different generators should be unique"
      );
    });
  });

  describe("bunch optimization", () => {
    it("should create a new bunch when generateAfter(null) is called", () => {
      const id = generator.generateAfter(null);

      expect(id.bunchId).to.equal("test-uuid-1");
      expect(id.counter).to.equal(0);
    });

    it("should extend the bunch when generating after the last ID in a bunch", () => {
      // Generate first ID
      const id1 = generator.generateAfter(null);
      expect(id1).to.deep.equal({ bunchId: "test-uuid-1", counter: 0 });

      // Generate second ID after first - should extend the bunch
      const id2 = generator.generateAfter(id1);
      expect(id2).to.deep.equal({ bunchId: "test-uuid-1", counter: 1 });

      // Generate third ID after second - should extend the bunch again
      const id3 = generator.generateAfter(id2);
      expect(id3).to.deep.equal({ bunchId: "test-uuid-1", counter: 2 });
    });

    it("should create a new bunch when given an unknown beforeId", () => {
      // Create an ID that wasn't generated by this generator
      const unknownId: ElementId = { bunchId: "unknown-bunch", counter: 5 };

      const newId = generator.generateAfter(unknownId);

      expect(newId.bunchId).to.equal("test-uuid-1");
      expect(newId.counter).to.equal(0);
    });

    it("should create a new bunch when the beforeId is not the last in its bunch", () => {
      // Generate a sequence of IDs
      const id1 = generator.generateAfter(null);
      const id2 = generator.generateAfter(id1);
      generator.generateAfter(id2);

      // Now try to generate after id1 (which is no longer the last in its bunch)
      const newId = generator.generateAfter(id1);

      expect(newId.bunchId).to.equal("test-uuid-2");
      expect(newId.counter).to.equal(0);
    });

    it("should handle interleaved generation correctly", () => {
      // Start two separate chains
      const chain1Id1 = generator.generateAfter(null);
      const chain2Id1 = generator.generateAfter(null);

      // Continue chain 1
      const chain1Id2 = generator.generateAfter(chain1Id1);

      // Continue chain 2
      const chain2Id2 = generator.generateAfter(chain2Id1);

      expect(chain1Id1.bunchId).to.equal("test-uuid-1");
      expect(chain2Id1.bunchId).to.equal("test-uuid-2");
      expect(chain1Id2.bunchId).to.equal("test-uuid-1");
      expect(chain2Id2.bunchId).to.equal("test-uuid-2");
    });

    it("should maintain separate counters for different bunches", () => {
      // Create multiple separate chains
      const chain1Start = generator.generateAfter(null);
      const chain2Start = generator.generateAfter(null);

      // Extend chain 1
      const chain1Next = generator.generateAfter(chain1Start);
      expect(chain1Next.counter).to.equal(1);

      // Extend chain 2
      const chain2Next = generator.generateAfter(chain2Start);
      expect(chain2Next.bunchId).to.equal(chain2Start.bunchId);
      expect(chain2Next.counter).to.equal(1);
    });
  });

  describe("count option", () => {
    it("should reserve space for multiple IDs when count > 1", () => {
      // Generate first ID with count=1 (default behavior)
      const id1 = generator.generateAfter(null);
      expect(id1).to.deep.equal({ bunchId: "test-uuid-1", counter: 0 });

      // Generate next ID normally - should be counter 1
      const id2 = generator.generateAfter(id1);
      expect(id2).to.deep.equal({ bunchId: "test-uuid-1", counter: 1 });

      // Generate ID with count=3, reserving space for 3 IDs
      const id3 = generator.generateAfter(id2, 3);
      expect(id3).to.deep.equal({ bunchId: "test-uuid-1", counter: 2 });

      // Next ID should skip the reserved space (counters 3, 4 are reserved)
      const id4 = generator.generateAfter(id3);
      expect(id4).to.deep.equal({ bunchId: "test-uuid-2", counter: 0 });
    });

    it("should handle count option when starting a new bunch", () => {
      // Start with count=5 on a new bunch
      const id1 = generator.generateAfter(null, 5);
      expect(id1).to.deep.equal({ bunchId: "test-uuid-1", counter: 0 });

      // Next generation should create new bunch since space is reserved
      const id2 = generator.generateAfter(id1);
      expect(id2).to.deep.equal({ bunchId: "test-uuid-2", counter: 0 });
    });

    it("should throw error for invalid count values", () => {
      expect(() => generator.generateAfter(null, 0)).to.throw(
        "Invalid count: 0"
      );
      expect(() => generator.generateAfter(null, -1)).to.throw(
        "Invalid count: -1"
      );
      expect(() => generator.generateAfter(null, 1.5)).to.throw(
        "Invalid count: 1.5"
      );
    });

    it("should work correctly with count=1 (default behavior)", () => {
      const id1 = generator.generateAfter(null, 1);
      const id1Default = generator.generateAfter(null);

      // Both should create new bunches and return counter 0
      expect(id1).to.deep.equal({ bunchId: "test-uuid-1", counter: 0 });
      expect(id1Default).to.deep.equal({ bunchId: "test-uuid-2", counter: 0 });

      // When extending, both explicit count=1 and default should behave the same
      const id2 = generator.generateAfter(id1, 1);
      const id2Default = generator.generateAfter(id1Default);

      expect(id2).to.deep.equal({ bunchId: "test-uuid-1", counter: 1 });
      expect(id2Default).to.deep.equal({ bunchId: "test-uuid-2", counter: 1 });
    });
  });
});
